import sys
import chilkat

#  Create two separate instances of the DH object.
dhBob = chilkat.CkDh()
dhAlice = chilkat.CkDh()

#  Unlock the component once at program startup...
success = dhBob.UnlockComponent("Anything for 30-day trial")
if (success != True):
    print(dhBob.lastErrorText())
    sys.exit()

#  The DH algorithm begins with a large prime, P, and a generator, G.
#  These don't have to be secret, and they may be transmitted over an insecure channel.
#  The generator is a small integer and typically has the value 2 or 5.

#  The Chilkat DH component provides the ability to use known
#  "safe" primes, as well as a method to generate new safe primes.

#  This example will use a known safe prime.  Generating
#  new safe primes is a time-consuming CPU intensive task
#  and is normally done offline.

#  Bob will choose to use the 2nd of our 8 pre-chosen safe primes.
#  It is the Prime for the 2nd Oakley Group (RFC 2409) --
#  1024-bit MODP Group.  Generator is 2.
#  The prime is: 2^1024 - 2^960 - 1 + 2^64 * { [2^894 pi] + 129093 }
dhBob.UseKnownPrime(2)

#  The computed shared secret will be equal to the size of the prime (in bits).
#  In this case the prime is 1024 bits, so the shared secret will be 128 bytes (128 * 8 = 1024).
#  However, the result is returned as an SSH1-encoded bignum in hex string format.
#  The SSH1-encoding prepends a 2-byte count, so the result is going  to be 2 bytes
#  longer: 130 bytes.  This results in a hex string that is 260 characters long (two chars
#  per byte for the hex encoding).

#  Bob will now send P and G to Alice.
p = dhBob.p()
g = dhBob.get_G()

#  Alice calls SetPG to set P and G.  SetPG checks
#  the values to make sure it's a safe prime and will
#  return False if not.
success = dhAlice.SetPG(p,g)
if (success != True):
    print("P is not a safe prime")
    sys.exit()

#  Each side begins by generating an "E"
#  value.  The CreateE method has one argument: numBits.
#  It should be set to twice the size of the number of bits
#  in the session key.

#  Let's say we want to generate a 128-bit session key
#  for AES encryption.  The shared secret generated by the Diffie-Hellman
#  algorithm will be longer, so we'll hash the result to arrive at the
#  desired session key length.  However, the length of the session
#  key we'll utlimately produce determines the value that should be
#  passed to the CreateE method.

#  In this case, we'll be creating a 128-bit session key, so pass 256 to CreateE.
#  This setting is for security purposes only -- the value
#  passed to CreateE does not change the length of the shared secret
#  that is produced by Diffie-Hellman.
#  Also, there is no need to pass in a value larger
#  than 2 times the expected session key length.  It suffices to
#  pass exactly 2 times the session key length.

#  Bob generates a random E (which has the mathematical
#  properties required for DH).

#eBob = dhBob.createE(256)
eBob = dhBob.createE(384)


#  Alice does the same:
#eAlice = dhAlice.createE(256)
eAlice = dhAlice.createE(384)

#  The "E" values are sent over the insecure channel.
#  Bob sends his "E" to Alice, and Alice sends her "E" to Bob.

#  Each side computes the shared secret by calling FindK.
#  "K" is the shared-secret.

#  Bob computes the shared secret from Alice's "E":
kBob = dhBob.findK(eAlice)

#  Alice computes the shared secret from Bob's "E":
kAlice = dhAlice.findK(eBob)

#  Amazingly, kBob and kAlice are identical and the expected
#  length (260 characters).  The strings contain the hex encoded bytes of
#  our shared secret:

''' Level ONE
print("Bob's shared secret:")
print(kBob)
print("Alice's shared secret (should be equal to Bob's)")
print(kAlice)
'''

#  To arrive at a 128-bit session key for AES encryption, Bob and Alice should
#  both transform the raw shared secret using a hash algorithm that produces
#  the size of session key desired.   MD5 produces a 16-byte (128-bit) result, so
#  this is a good choice for 128-bit AES.

#  Here's how you would use Chilkat Crypt (a separate Chilkat component) to
#  produce the session key:
crypt = chilkat.CkCrypt2()
success = crypt.UnlockComponent("Anything for 30-day trial.")
if (success != True):
    print(crypt.lastErrorText())
    sys.exit()

#crypt.put_EncodingMode("hex")
crypt.put_EncodingMode("hex")

#  An initialization vector is required if using CBC or CFB modes.
#  ECB mode does not use an IV.
#  The length of the IV is equal to the algorithm's block size.
#  It is NOT equal to the length of the key.

crypt.put_HashAlgorithm("md5")

sessionKey = crypt.hashStringENC(kBob)

''' Level TWO
print("128-bit Session Key:")
print(sessionKey)
'''


#  Specify 3DES for the encryption algorithm:
crypt.put_CryptAlgorithm("3des")

#  CipherMode may be "ecb" or "cbc"
crypt.put_CipherMode("cbc")

#  KeyLength must be 192.  3DES is technically 168-bits;
#  the most-significant bit of each key byte is a parity bit,
#  so we must indicate a KeyLength of 192, which includes
#  the parity bits.

#  Encrypt something...
''''crypt.put_CryptAlgorithm("aes")
crypt.put_KeyLength(128)
'''
#crypt.put_CipherMode("cbc")

#  Use an IV that is the MD5 hash of the session key...

iv = crypt.hashStringENC(sessionKey)

'''LEVEL THREE
#  AES uses a 16-byte IV:
print("Initialization Vector:")
print(iv)
'''

crypt.SetEncodedKey(sessionKey,"hex")
crypt.SetEncodedIV(iv,"hex")


'''
#TESTING
#  Encrypt some text:

crypt.put_EncodingMode("base64")
cipherText64 = crypt.encryptStringENC("The quick brown fox jumps over the lazy dog")
print('ciphertext is')
print(cipherText64)
def printhello():
    print (cipherText64)
plainText = crypt.decryptStringENC(cipherText64)

print(plainText)'''



crypt.put_KeyLength(192)

#  The padding scheme determines the contents of the bytes
#  that are added to pad the result to a multiple of the
#  encryption algorithm's block size.  3DES has a block
#  size of 8 bytes, so encrypted output is always
#  a multiple of 8.
crypt.put_PaddingScheme(0)

#  EncodingMode specifies the encoding of the output for
#  encryption, and the input for decryption.
#  It may be "hex", "url", "base64", or "quoted-printable".


#  Encrypt a string...
#  The input string is 44 ANSI characters (i.e. 44 bytes), so
#  the output should be 48 bytes (a multiple of 8).
#  Because the output is a hex string, it should
#  be 96 characters long (2 chars per byte).
